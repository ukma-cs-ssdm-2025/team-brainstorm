## 1) Резервація без верифікованого користувача (Ковтонюк)

- Проблема
  - Фронтенд генерував випадковий `user_id` для створення резервації, а бекенд приймав будь‑який UUID без перевірки, що такий користувач існує у БД.

- Код (фрагмент)
  - frontend/app.js:95
    ```js
    const user_id = crypto.randomUUID();
    const payload = { user_id, book_id: b.id, until: untilStr };
    ```
  - src/api/routes/reservations.py:26 (до виправлення очікувався обов’язковий `user_id` у тілі запиту; резолву користувача не було)
  - src/services/reservations_service.py:12 (до виправлення не перевірявся факт існування `user_id` у БД перед створенням записи)

- Чому вона небезпечна
  - Порушення цілісності даних: з’являються “сирітські” резервації, що не належать жодному реальному користувачу.
  - Відсутність трасованості та аудиту: неможливо однозначно пов’язати дію із конкретним користувачем.
  - Помилки бізнес‑логіки: нагадування/повідомлення не мають email, неможливо комунікувати з користувачем.

- Потенційний вплив
  - Хибні або відсутні нагадування щодо повернення книг.
  - Можливість зловмиснику створювати резервації від імені “вигаданих” користувачів (довільні UUID).
  - Забруднення даних та ускладнення подальшої міграції/інтеграції.

Примітка: Виправлено шляхом передачі `X-User-Email` з фронтенда і резолву/перевірки користувача на бекенді; за відсутності існуючого користувача — створюється мінімальний запис або запит відхиляється (залежно від політики).

4) Відсутність обробки помилок при доступі до файлу e-book (Зінченко)

Проблема

Endpoint /books/{book_id}/ebook повертає PDF-файл без обробки можливих помилок читання (пошкоджений файл, відсутні права доступу, IOError).


Код (фрагмент)

src/api/routes/books.py:158-162



python    if not abs_path.exists():
        raise HTTPException(status_code=404, detail=f"E-book file not found: {abs_path}")
    
    return FileResponse(
        abs_path,
        media_type="application/pdf",
        filename=f"{book['title'].replace(' ', '_')}.pdf"
    )

Чому вона небезпечна

Якщо файл існує, але пошкоджений або недоступний для читання — сервер поверне 500 Internal Server Error.
Відсутнє логування спроб доступу до файлів (проблема безпеки та аудиту).
Користувач бачить технічні деталі внутрішньої помилки замість зрозумілого повідомлення.
Неможливо відстежити проблеми з файловою системою або правами доступу.


Потенційний вплив

Погане враження від системи через незрозумілі помилки.
Неможливість діагностувати проблеми з файловою системою.
Потенційний витік інформації про внутрішню структуру файлів.
При масових проблемах з файлами — повна недоступність функції e-book.



Примітка: Потребує додавання try/except для IOError, PermissionError, перевірки is_file() та логування всіх спроб доступу до файлів.

5) Відсутність таймауту на операції з DB_LOCK (Зінченко)

Проблема

Всі операції з DB_LOCK використовують звичайний with DB_LOCK: без таймауту, що може призвести до deadlock або нескінченного очікування при конкурентному доступі.


Код (фрагмент)

src/services/reservations_service.py:12



python    def create_reservation_for_user(user_id, book_id, until_date=None):
        with DB_LOCK:  # ❌ Немає timeout
            if user_id not in USERS:
                raise HTTPException(...)
            # ... довгі операції з БД

src/services/reviews_service.py:18 (аналогічно без timeout)
src/services/user_service.py:11 (аналогічно без timeout)
Чому вона небезпечна

При багатопотоковій роботі один "завислий" запит блокує весь сервіс назавжди.
Deadlock може зупинити всю систему без можливості автоматичного відновлення.
API перестає відповідати на всі запити — повна недоступність сервісу.
Відсутність механізму детектування та recovery від deadlock.


Потенційний вплив

Всі користувачі не можуть користуватися системою (повна відмова сервісу).
503 Service Unavailable або timeout на стороні клієнта.
Необхідність ручного перезапуску сервера для відновлення роботи.
Втрата довіри користувачів через "зависання" системи.



Примітка: Критична проблема для продакшену! Потребує використання DB_LOCK.acquire(timeout=5) з обробкою випадку неможливості захоплення локу та обов'язкового finally: DB_LOCK.release() для гарантованого звільнення ресурсу.
